- name: Fail if data disk ID is missing
  fail:
    msg: "cloudypad_data_disk_id must be set"
  when: cloudypad_data_disk_id is not defined

# Reboot to ensure all block devices are properly initialized
# Some providers (e.g., AWS with instance stores + EBS volumes) have unstable device order
# A reboot helps ensure consistent device detection
- name: Reboot to stabilize device detection
  reboot:
    msg: "Rebooting to ensure all block devices are properly initialized"
    reboot_timeout: 300
  when: cloudypad_data_disk_reboot_required | default(false)

- name: copy wait-for-disk.sh to /usr/local/bin
  become: true
  copy:
    src: wait-for-disk.sh
    dest: /usr/local/bin/wait-for-disk.sh
    mode: '0755'

# The wait-for-disk.sh script will wait up to 3 minutes for the specific disk to be available
# It checks for the exact volume ID, excludes instance stores and root disk
# Returns the correct device name (e.g., nvme1n1)
- name: Wait for data disk and get device name
  shell: /usr/local/bin/wait-for-disk.sh "{{ cloudypad_data_disk_id }}"
  register: disk_detection_result
  changed_when: false
  failed_when: false

- name: Set disk name from script result
  set_fact:
    cloudypad_data_disk_name: "{{ disk_detection_result.stdout | trim }}"
  when: disk_detection_result.rc == 0 and disk_detection_result.stdout | trim | length > 0

# Fallback to ansible_devices if script failed
- name: Find disk matching data disk ID using ansible facts
  set_fact:
    cloudypad_data_disk_name: >-
      {{
        hostvars[inventory_hostname].ansible_devices
        | dict2items
        | selectattr('value.links.ids', 'defined') 
        | selectattr('value.links.ids', 'match', '.*' + cloudypad_data_disk_id)
        | map(attribute='key')
        | list
        | first
        | default(
          hostvars[inventory_hostname].ansible_devices
          | dict2items
          | selectattr('value.serial', 'defined')
          | selectattr('value.serial', 'match', '.*' + cloudypad_data_disk_id)
          | map(attribute='key')
          | list
          | first, true
        )
      }}
  when: cloudypad_data_disk_name is not defined or cloudypad_data_disk_name | length == 0

- debug:
    msg: "Found disk for '{{ cloudypad_data_disk_id }}': '{{ cloudypad_data_disk_name }}'"

- set_fact:
    cloudypad_data_disk_path: "/dev/{{ cloudypad_data_disk_name }}"

- name: fail if no disk was found
  fail:
    msg: "No disk found matching data disk ID '{{ cloudypad_data_disk_id }}'"
  when: cloudypad_data_disk_name is not defined

- name: Format Cloudy Pad data disk (ext4)
  filesystem:
    fstype: "ext4"
    dev: "{{ cloudypad_data_disk_path }}"

- name: Ensure Cloudy Pad data directory exists
  file:
    path: "{{ cloudypad_data_root }}"
    state: directory
    owner: root
    group: root
    mode: '0755'

# Some data may already be present on disk before mounting the data disk
# To avoid losing data, move it to a temporary location before mounting the data disk
# Copy and execute bash script to move data before mounting
- name: Copy move-data-before-disk-mount.sh script
  template:
    src: move-data-before-disk-mount.sh
    dest: /usr/local/bin/move-data-before-disk-mount.sh
    mode: '0755'

- name: Move existing data before disk mount (if any)
  shell: /usr/local/bin/move-data-before-disk-mount.sh

- name: Mount and configure fstab for Cloudy Pad data disk
  mount:
    path: "{{ cloudypad_data_root }}"
    src: "{{ cloudypad_data_disk_path }}"
    fstype: "ext4"
    state: mounted

    # Do not fail if the disk is not found at boot
    # Oherwise instance won't boot at all if disk is missing
    # Better have an instance that boots with data loss rather than unbootable instance
    opts: "defaults,nofail"

# Copy and execute bash script to move data back after mounting
- name: Copy move-data-after-disk-mount.sh script
  template:
    src: move-data-after-disk-mount.sh
    dest: /usr/local/bin/move-data-after-disk-mount.sh
    mode: '0755'

- name: Move existing data back after disk mount (if any)
  shell: /usr/local/bin/move-data-after-disk-mount.sh
